2019-09-09
<h1>객체 지향 프로그래밍 (Object-Oriented Programming, OOP)</h1>

<h2>1. 객체 지향 프로그래밍-생활코딩</h2>

<a>https://opentutorials.org/course/743/6553</a>
<h3>객체 지향 프로그래밍</h3>
<ol>
- 프로그래밍 패러다임으로 로직을 <b>상태(state)와 행위(behave)</b>로 이루어진 객체로 만드는 것<br>
- 객체는 <b>변수와 메소드를 그룹핑</b>한 것<br>
- 하나의 프로그램 : 여러가지 목적성(기능, 취지)을 가지고 있는 로직들의 집합<br>
- 재활용성 (이미 사용하고 있는 로직을 다른 사이트/ 어플리케이션에도 적용 가능)
</ol><p>
<h3>문법과 설계</h3>
<b><u>문법</u></b>
<ol>
-문법을 이해하고 숙지해야 객체를 만들 수 있다.</ol>
<b><u>설계</u></b>
<ul>
- 좋은 객체를 만드는 법, 현실을 잘 software화 하는 법. 하지만 현실은 복잡하고 software는 간단함 <br>
- <b>추상화(abstract)</b> : 복잡함 속에서 필요한 관점만을 추출하는 행위, 해결해야 할 문제를 software화해서 단순하게 만드는 행위.<br><p>
- 고도의 추상화 능력이 필요함<br>
- 객체지향의 설계 원칙, 철학적 의미는 대단히 중요함<br>
- 객체지향 문법을 배우고 어떻게 동작하는지 충분히 이해한 다음에 원칙 이야기 가능
 </ul>
<h3>부품화</h3>
<ul>
- 객체가 일종의 부품으로써 사용되는 것. <br>
- 부품화가 중요하지만, 그보다 더 중요한 것은 적절함/적합함<br>
- 메소드 : 부품화의 예, 프로그램이 발전하며 메소드가 많아지며 부품화의 의미가 사라짐 -> 객체지향 프로그래밍으로 발전<br>
</ul>
<h3>은닉화(Information Hiding), 캡슐화(Encapsulation)</h3>
- 내부의 동작 방법을 객체 안으로 숨기고 사용 방법만 노출하는 컨셉. <br>
<br>
<h3>인터페이스</h3>
- ex. 모니터와 컴퓨터를 연결하는 규격이 HDMI로 표준화<br>
- 연결점 = 인터페이스 ~ 소프트웨어적으로 제공<br><br>
+++ 비유로 완전히 이해 불가능, <b>only in software : 복제와 상속</b><br>

<h2>2. 객체 지향 프로그래밍-위키백과</h2>
https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D

 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.<p>
객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 또한 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점을 갖고 있다. 그러나 지나친 프로그램의 객체화 경향은 실제 세계의 모습을 그대로 반영하지 못한다는 비판을 받기도 한다.
<br>
<h3>기본 구성 요소</h3>
<ul>
•	클래스(Class) - 같은 종류(또는 문제 해결을 위한)의 집단에 속하는 속성(attribute)과 행위(behavior)를 정의한 것으로 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user defined data type)이라고 할 수 있다. 클래스는 다른 클래스 또는 외부 요소와 독립적으로 디자인하여야 한다. 프로그래머는 아니지만 해결해야 할 문제가 속하는 영역에 종사하는 사람이라면 클래스를 사용할 수 있다.<br><br>
•	객체(Object) - 클래스의 인스턴스(실제로 메모리상에 할당된 것)이다. 객체는 자신 고유의 속성(attribute)을 가지며 클래스에서 정의한 행위(behavior)를 수행할 수 있다. 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용한다.<br><br>
•	메서드(Method), 메시지(Message) - 클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 메시지라 할 수 있다. 메서드는 한 객체의 서브루틴(subroutine) 형태로 객체의 속성을 조작하는 데 사용된다. 또 객체 간의 통신은 메시지를 통해 이루어진다.<br></ul>
<h3>특징</h3>
<ul>
* <b>자료 추상화</b><br>
-자료 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것이다. 자료 추상화를 통해 정의된 자료형을 추상 자료형이라고 한다. 추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다. 객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.<br><br>
* <b>상속</b><br>
- 상속은 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능이다. 상속을 받는 새로운 클래스를 부클래스, 파생 클래스, 하위 클래스, 자식 클래스라고 하며 새로운 클래스가 상속하는 기존의 클래스를 기반 클래스, 상위 클래스, 부모 클래스라고 한다. 상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.<br><br>
* <b>다중 상속</b><br>
- 다중 상속은 클래스가 2개 이상의 클래스로부터 상속받을 수 있게 하는 기능이다. 클래스들의 기능이 동시에 필요할 때 용이하나 클래스의 상속 관계에 혼란을 줄 수 있고(예: 다이아몬드 상속) 프로그래밍 언어에 따라 사용 가능 유무가 다르므로 주의해서 사용해야 한다. JAVA는 지원하지 않는다.<br><br>
* <b>다형성 개념</b><br>
- 다형성 개념이란 어떤 한 요소에 여러 개념을 넣어 놓는 것으로 일반적으로 오버라이딩(같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것)이나 오버로딩(같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것)을 의미한다. 다형 개념을 통해서 프로그램 안의 객체 간의 관계를 조직적으로 나타낼 수 있다.<br><br>
* <b>동적 바인딩</b><br>
- 동적 바인딩은 실행 시간 중에 일어나거나 실행 과정에서 변경될 수 있는 바인딩으로 컴파일 시간에 완료되어 변화하지 않는 정적 바인딩과 대비되는 개념이다. 동적 바인딩은 프로그램의 한 개체나 기호를 실행 과정에 여러 속성이나 연산에 바인딩함으로써 다형 개념을 실현한다.<br></ul>
<h3>장점</h3>
 S/W의 질을 향상하기 위해 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향해야 하는데, OOP의 경우 클래스에 하나의 문제 해결을 위한 데이터를 모아 놓은 데이터형을 사용함으로써 응집력을 강화하고, 클래스간에 독립적으로 디자인함으로써 결합력을 약하게 할 수 있다.
<br>
<h2>3. 객체 지향 프로그래밍-블로그 참조</h2>

<a>https://see-ro-e.tistory.com/108</a>
<h3>객체</h3>
ex)슈퍼마리오 게임 : 마리오, 아이템, 블록, 적, 미사일 등이 복합적으로 상호작용하는 게임.
<ul><br>- 상호작용하는 각각의 요소들이 전부 객체</ul>
<h3>클래스</h3>
ex) 마리오라는 객체 생성하기 위해 게임 캐릭터라는 틀(class)를 만든 후 객체를 만들 수 있음.
<ul>- 데이터와 함수가 결합되어 있는 <b>내가 만든 자료형(사용자 정의 자료형)</b>
<br>- 구조체의 개념에 함수를 추가한 것. </ul>

<h3>객체 지향 프로그래밍 사용 이유</h3>
<ul>
1. 행동을 하는 주체(객체)와 행동(함수)가 묶여 누가 무엇을 하는지 명확함.
<br>ex) mario.jump() / enemy.jump() ... vs myJump() / enemyJump()<br> 
2. 어디서 잘못되었는지 명확함, 즉 디버깅이 쉬움 (해당 클래스만 수정하면 됨)
<br>cf) 절차지향 - 어떤 기능이 잘못되면 어디서 잘못되었는지 알기 힘들어짐
</ul>
<h2>4. 객체 지향 프로그래밍-유튜브 참조</h2>
https://www.youtube.com/watch?v=GwL5uUP7F1Y
<h3>class, object from 플라톤</h3>
-Idea : 추상적인 세계에 존재하는 완벽한 원본 <br>
-Replica : 추상적인 무엇인가를 현실에 구체화 시켜만든 복제본<br>
<h3>CLASS, OBJECT</h3>
-CLASS : <ul>- 이상적인 세계에 존재하는 단 하나의 기준<br>- 실제로는 존재하지 않음<br>- 가장 중요한 특성만 개략적으로 알려줌<br>- 구체적인 수치가 없음</ul>
-OBJECT : <ul>- 자기 자신을 스스로 챙길 수 있다.<br>
- 하나의 온전한 단위로 실존하는 세상에 존재한다.<br>
- 하나의원본에서 파생되어도 서로 구분 가능하다</ul><br>
ex)CLASS : 자동차 틀(원형) / OBJECT : 자동차 틀을 가지고 만들어낸 자동차들


<h3>call by reference</h3>
- 미리 만들어진 것을 '가져와서 쓴다'는 개념

- 변수는 실제 존재하는 object를 가리키는 화살표
